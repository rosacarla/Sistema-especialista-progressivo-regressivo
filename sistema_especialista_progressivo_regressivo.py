# -*- coding: utf-8 -*-
"""Sistema-Especialista-Progressivo-Regressivo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fEb5RehS5Nfh1Oi_6J68JV8PX2fq2nzg

# <b>SISTEMA ESPECIALISTA COM ENCADEAMENTO PROGRESSIVO E REGRESSIVO: estudo de caso do ExpertSystem (Scalabrin)</b>

<b>Instituição:</b> PUCPR  
<b>Curso:</b> Tecnologia em Inteligência Artificial Aplicada  
<b>Disciplina:</b> Engenharia do Conhecimento  
<b>Professor:</b> Felipe Gabriel de Mello Elias  
<b>Estudante:</b> Carla Edila Silveira  
<p align='justify'>
<b>Objetivo:</b> testar o código de um sistema especialista; verificar como pode ser construída uma base de regras de produção e como o mecanismo de inferência pode, a partir dessa base, solucionar um problema com uso do encadeamento progressivo ou regressivo. </p>
<b>DATA: 03/04/2024 </b>  
</br>  
</br>  

<img src='https://i.postimg.cc/SxZrpcGN/cabecalho-ec.png'>

>### <b>Introdução</b>  
<p align='justify'>
Este notebook traz anotações de uma atividade prática a fim de testar um sistema especialista que executa raciocínios de encadeamento progressivo e regressivo. Contém o código de um software que implementa mecanismos de encadeamento progressivo e regressivo. </p>  
<p align='justify'>
A implementação do software foi desenvolvida na linguagem de programação Python, originalmente, pelo professor Edson E. Scalabrin da PUCPR. Esta versão é uma recodificação parcial do código descrito, em 1993, por Bigus &
Bigus em Python. </p>  
<p align='justify'>
Foram mantidos apenas os códigos necessários para montar e processar regras booleanas. A implementação original não faz parte da recodificação da parte gráfica. Para realizar a atividade, foi fornecido o arquivo compactado <b>ExpertSystem.zip</b> e outro arquivo com instruções (tutorial) de como testar o software.  </p>

> ### <b>Encadeamento progressivo e regressivo</b>  

<p align='justify'> Antes de explicar os procedimentos necessários para utilizar o sistema especialista da atividade prática, apresentam-se considerações sobre endadeamento progressivo e regressivo. É uma tentativa amparar a compreensão do que está envolvido no desenvolvimento do programa.</p>

<p align='justify'> Quanto aos <b>sistemas especialistas</b>, são sistemas de inteligência artificial que tentam emular o raciocínio humano em um domínio específico de conhecimento. São construídos com uma base de conhecimento que contém uma série de <b>regras de produção</b> que representam o conhecimento especializado em um determinado domínio.</b>  

<p align='justify'> As regras de produção são escritas para capturar o conhecimento de especialistas humanos no domínio em questão. Elas são compostas de condições (ou antecedentes) e ações (ou consequências). Quando as condições são atendidas, a ação correspondente é acionada. Segue uma exemplificação com a proposição: <i>Se a temperatura é superior a 30 graus Celsius, então ligue o ar condicionado.</i> Neste exemplo, a condição é que a temperatura seja superior a 30 graus Celsius e a ação é ligar o ar condicionado.</p>  

<p align='justify'> Assim, as regras de produção são executadas por meio de 2 abordagens de raciocínio: <b>raciocínio progressivo</b> e <b>raciocínio regressivo</b>.</p>
<p align='justify'> <b>1. Raciocínio Progressivo</b>: Neste método, as regras de produção são aplicadas de forma progressiva em direção a um objetivo ou solução. Começando com dados iniciais ou estado atual do problema, as regras são aplicadas em sequência até que uma solução seja alcançada ou um estado desejado seja atingido. Cada regra aplicada pode gerar novas informações ou atualizar o estado atual do problema. Esse processo continua até que não haja mais regras aplicáveis ou até que o objetivo seja alcançado.</p>

<p align='justify'> <b>2. Raciocínio Regressivo</b>: Ao contrário, o raciocínio regressivo começa com um objetivo ou estado desejado e trabalha retroativamente para determinar quais regras de produção podem ser aplicadas para alcançar o objetivo. Usa a estratégia "backward chaining", na qual se começa com o objetivo final e trabalha-se de volta para os dados iniciais ou condições necessárias para alcançar esse objetivo. A cada passo, as regras são aplicadas de forma regressiva, retrocedendo na cadeia de raciocínio até que uma solução ou conclusão seja alcançada.</p>  

<p align='justify'> Ambas as abordagens têm suas aplicações e são utilizadas em diferentes contextos, conforme a natureza do problema e das preferências do desenvolvedor ou do sistema de inteligência artificial. O raciocínio progressivo é frequentemente usado em sistemas de inferência e processamento de dados, enquanto o raciocínio regressivo pode ser mais eficaz em problemas de planejamento ou diagnóstico.</b>

> ### <b>Sobre o pacote</b>  

Após extrair o conteúdo do arquivo <b>ExpertSystem.zip</b>, encontram-se pastas e arquivos com esta estrutura:
</br>  

<img src='https://i.postimg.cc/0jHFFBZG/estrutura-pacote.png'>  

</br>  

<p align='justify'>
É necessário ter o Python instalado e configurado no ambiente para executar o software. Caso não tenha ainda, recomenda-se providenciar a instalação conforme a instruções passadas no site Python.org para cada tipo de sistema operacional:</b>  

• Windows: http://python.org.br/instalacao-windows/  
• MacOS: http://python.org.br/instalacao-mac/  
• Linux: http://python.org.br/instalacao-linux/

> ### <b> Como o software funciona</b>  

<p align='justify'> Para execução de raciocínio com encadeamento progressivo, o texto a seguir foi elaborado pelo prof. Edson E. Scalabrin (2019): “Para ilustrar a aplicação do encadeamento progressivo sobre a base de regras “como  um meio de transporte para ir ao cinema”, a partir daqui chamaremos tal base de “indo ao cinema”. Devem-se seguir estes passos:</b>  

<p align='justify'> <b>1) Carregar a base de regras “indo ao cinema” no mecanismo de inferência</b>; para ajudar a testar o mecanismo de encadeamento progressivo há uma código em Python no final deste notebook. Mesmo assim, partes desse código serão exibidtas e explicadas daqui em diante, especialmente as que podem ser modificadas a fim de compor outras bases de regras.</p>

```python
Regra 01: SE distancia > 5
        ENTÃO deslocamento = carro
Regra 02: SE distancia > 1 E
          tempo < 15
        ENTÃO deslocamento = carro
Regra 03: SE distancia > 1 E
          tempo > 15
        ENTÃO deslocamento = a-pe
Regra 04: SE deslocamento = carro E
          localDoCinema = centro
        ENTÃO meioDeTransporte = taxi
Regra 05: SE deslocamento = carro E
          localDoCinema = bairro
        ENTÃO meioDeTransporte = carro-proprio
Regra 06: SE deslocamento = a-pe E
          clima = ruim
        ENTÃO meioDeTransporte = a-pe-triste
Regra 07: SE deslocamento = a-pe E
          clima = bom
        ENTÃO meioDeTransporte = a-pe-feliz
```

<p align='justify'> O conjunto de regras apresentadas são também exibidas em Python (ver abaixo), onde a função <i>create</i> define o script que cria a base de regras “indo ao cinema”. Essa parte do programa e demais funcionalidades podem ser verificadas no final do notebook.</p>

``` python
    def create(self):
        distancia = RuleVariable(self.br, "distancia")
        distancia.set_labels("1 50")
        distancia.set_prompt_text("Qual é a distância até o cinema [1,50]?")

        deslocamento = RuleVariable(self.br, "deslocamento")
        deslocamento.set_labels("carro a-pe")
        deslocamento.set_prompt_text(
            "Qual é a forma de deslocameto [carro, a-pe]?")

        tempo = RuleVariable(self.br, "tempo")
        tempo.set_labels("0 60")
        tempo.set_prompt_text("Qual é o tempo disponível [1,60]?")

        local_do_cinema = RuleVariable(self.br, "localDoCinema")
        local_do_cinema.set_labels("centro bairro")
        local_do_cinema.set_prompt_text("Onde é o cinema [centro, bairro]]?")

        meio_de_transporte = RuleVariable(self.br, "meioDeTransporte")
        meio_de_transporte.set_labels(
            "taxi carro-proprio a-pe-triste a-pe-feliz")
        meio_de_transporte.set_prompt_text(
            "Qual é o meio de transporte [taxi, carro-proprio, a-pe-triste, a-pe-feliz]]?")

        clima = RuleVariable(self.br, "clima")
        clima.set_labels("ruim bom")
        clima.set_prompt_text("Como está o clima [bom, ruim]?")

        c_equals = Condition("=")
        c_more_then = Condition(">")
        c_less_than = Condition("<")

        Regra01 = Rule(self.br, "Regra 01",
                       [Clause(distancia, c_more_then, "5")],
                       Clause(deslocamento, c_equals, "carro"))

        Regra02 = Rule(self.br, "Regra 02",
                       [Clause(distancia, c_more_then, "1"),
                        Clause(tempo, c_less_than, "15")],
                       Clause(deslocamento, c_equals, "carro"))

        Regra03 = Rule(self.br, "Regra 03",
                       [Clause(distancia, c_more_then, "1"),
                        Clause(tempo, c_more_then, "15")],
                       Clause(deslocamento, c_equals, "a-pe"))

        Regra04 = Rule(self.br, "Regra 04",
                       [Clause(deslocamento, c_equals, "carro"),
                        Clause(local_do_cinema, c_equals, "centro")],
                       Clause(meio_de_transporte, c_equals, "taxi"))

        Regra05 = Rule(self.br, "Regra 05",
                       [Clause(deslocamento, c_equals, "carro"),
                        Clause(local_do_cinema, c_equals, "bairro")],
                       Clause(meio_de_transporte, c_equals, "carro-proprio"))

        Regra06 = Rule(self.br, "Regra 06",
                       [Clause(deslocamento, c_equals, "a-pe"),
                        Clause(clima, c_equals, "ruim")],
                       Clause(meio_de_transporte, c_equals, "a-pe-triste"))

        Regra07 = Rule(self.br, "Regra 07",
                       [Clause(deslocamento, c_equals, "a-pe"),
                        Clause(local_do_cinema, c_equals, "bom")],
                       Clause(meio_de_transporte, c_equals, "a-pe-feliz"))
        return self.br
```

<b> 2) Definir um conjunto de valores iniciais para as variáveis na memória de trabalho.</b>  

MEMÓRIA DE TRABALHO  
distancia = 2  
deslocamento = None  
tempo = 10  
localDoCinema = centro  
meioDeTransporte = None  
clima = ruim

``` python
# Definição do conjunto de valores iniciais das variaáveis em Python:
self.br.set_variable_value("distancia", "2")
self.br.set_variable_value("deslocamento", None)
self.br.set_variable_value("tempo", "10")
self.br.set_variable_value("localDoCinema", "centro")
self.br.set_variable_value("meioDeTransporte", None)
self.br.set_variable_value("clima", "ruim")
```

<p align='justify'> <b>3) Examinar as cláusulas antecedentes de cada regra para determinar quais podem ser acionadas.</b></p>  

<p align='justify'>Como o valor para distância não é superior a cinco, a regra 01 não pode ser disparada, apenas uma regra é disparada, a regra 02. Em outras palavras, o conjunto de conflitos para o primeiro ciclo de correspondência encerra apenas uma regra, a regra 02.</p>

``` python
Regra 01: SE distancia > 5
        ENTÃO deslocamento = carro
Regra 02: SE distancia > 1 E
          tempo < 15
        ENTÃO deslocamento = carro
```

<p align='justify'> Para a resolução de conflitos, seleciona-se a regra única. Quando se dispara o mecanismo de ação, a regra obriga a vincular o valor "carro" à variável "deslocamento" e adicioná-lo à memória de trabalho.<p>

``` python
self.br.set_variable_value("deslocamento", “carro”)
```

| MEMÓRIA DE TRABALHO |
|---------------------|
|distancia = 2        |
deslocamento = carro
tempo = 10
localDoCinema = centro
meioDeTransporte =
None
clima = ruim  

</br>

<p align='justify'> Neste ponto, tem-se a preparação para o próximo ciclo de inferências. Há uma comparação das regras para determinar quais podem ser disparadas. Como o <b>deslocamento</b> tem um valor, duas regras são candidatas: 04 e 05. </p>  

<p align='justify'> A regra 05 requer <b>localDoCinema = bairro</b>, por isso, é falsa e sobra somente a regra 04, porque todas as cláusulas antecedentes são satisfeitas para a regra 04, com <b>deslocamento
= carro</b> e <b>localDoCinema = centro</b>.</p>

``` python
Regra 04: SE deslocamento = carro E
          localDoCinema = centro
        ENTÃO meioDeTransporte = taxi
Regra 05: SE deslocamento = carro E
          localDoCinema = bairro
        ENTÃO meioDeTransporte = carro-proprio  
```  


Com aplicação da regra 04 obtém-se como resultado um novo valor para <b>meio de transporte</b> à memória de trabalho.  

``` python  
self.br.set_variable_value("meioDeTransporte", “taxi”)  
```

| MEMÓRIA DE TRABALHO |
|---------------------|
|distancia = 2        |
deslocamento = carro
tempo = 10
localDoCinema = centro
meioDeTransporte = taxi
clima = ruim  

<p align='justify'>O ciclo continua até que uma condição de parada seja atingida. Porém, percebe-se que apenas uma regra foi acionada novamente, a regra 04. O conjunto de conflitos está vazio, então a inferência progressiva encerra. Deve-se notar que se iniciou com quatro fatos e calcularam-se dois outros fatos, derivando <b>taxi</b> como <b>meio de transporte</b>.</p>  

<p align='justify'>Mostrou-se uma abordagem bastante simples de processamento de regras em modo progressivo, porém esta não é a mais eficiente para grandes bases de regras. Nesta linha, o algoritmo <i>Rete</i> constrói uma estrutura de dados de rede para gerenciar as dependências entre dados, testes de condição e regras. Esta abordagem minimiza o número de testes necessários para cada operação de correspondência (Forgy, 1982). Contudo, a grande parte dos sistemas que empregam encadeamento progressivo usam métodos que são menos eficientes, mas mais fáceis de implementar. <i>- Edson E. Scalabrin (2019)</i>. </b>

> ### <b> Execução do código</b>  

<p align='justify'> A execução do software requer a navegação até a pasta com o arquivo <b>Main.py</b> e uso de comando do Python. No Windows é possível realizar esse procedimento com a seguinte linha de comando:</p>  

``` python
C:\Users\ExpertSystem\ExpertSystem\app\cinema>python Main.py
```   

Em seguida, o software produz uma saída na tela com as opções para escolha do usuário:

</br>  

<img src='https://i.postimg.cc/MpbdRhCq/saida-expert-software.png'>

<p align='justify'> Primeiramente, deve-se digitar o valor "1" para carregar as regras. Será possível visualizar todas as regras carregadas após digitar o valor “2” para o software exibir esta saída: </p>
</br>  

<img src='https://i.postimg.cc/m2yf86M2/saida-expert2.png'>

<p align='justify'> Para carregar as variáveis iniciais para o exemplo simples de encadeamento progressivo, pressiona-se o valor “3”. Nesta saída, observa-se  que ainda são desconhecidas as variáveis <b>deslocamento value</b> e <b>meioDeTransporte value</b>, pois ambas estão definidas
como <b>None</b>. </p>    

</br>

<img  src='https://i.postimg.cc/50yLkG6c/saida-expert3.png'>

<p align='justify'> Para executar o encadeamento progressivo que dispara as regras com base nas variáveis (premissas) iniciais, digita-se o valor “4”. Na sequência, o software preenche as variáveis que estavam com valor <b>None</b>.</p>  

</br>

<img src='https://i.postimg.cc/d0WXZLX8/saida-expert4.png'>

<p align='justify'> Para o carregamento das variáveis de encadeamento regressivo, digita-se o valor “5”. Observa-se que todas as variáveis iniciais (premissas) estão configuradas com o valor <b>None</b>, exceto <b>localDoCinema value</b>” e <b>clima value</b>. Quando se tem poucas variáveis iniciais é recomendado utilizar o encadeamento regressivo.</p>  

</br>

<img src='https://i.postimg.cc/QNpM1D8F/saida-expert5.png'>

<p align='justify'> Para executar o encadeamento regressivo, dita-se o valor “6”. Como observado, por haver poucas variáveis, o software solicita que o usuário informe qual seria a variável objetivo. Para responder, o usuário deve digitar <b>deslocamento</b> ou <b>meioDeTransporte</b>. </p>  

</br>

<img src='https://i.postimg.cc/cC8kgTy3/saida-expert6.png'>

<p align='justify'> Com a digitação de <b>deslocamento</b>, o software interage de novo com o usuário para solicitar uma entrada para a distância (entre “1” e “50”). Case se digite o valor “10”, automaticamente há execução do encadeamento regressivo com as variáveis definidas (escolhidas) pelo usuário.</p>  
<p align='justify'> Apresenta-se na Fig. 7 o resultado do ciclo de inferência para encadeamento regressivo e a entrada <b>deslocamento value</b> que foi configurada para <b>carro</b>, e chega-se ao final da execução. </p>  

</br>

<img src='https://i.postimg.cc/PrSKXB87/saida-expert7.png'>

> ### <b>Conteúdo dos arquivos</b>  

<p align='justify'> Para montar uma nova base de regras, é necessário apenas ajustar as classes <b>Main</b> e <b>RuleBaseCinema</b>. No arquivo “Main.py” estão a classe Main e definições iniciais do software, conforme se apresenta a seguir:</p>  

``` python
from ExpertSystem.api.esMenu import APP
from ExpertSystem.app.cinema.RuleBaseCinema import RuleBaseCinema

class Main:
    def __init__(self):
        self.app = APP("Rule Application")

    def main(self):
        try:
            # RuleBaseCinema recebe dois parâmetros:
            # o primeiro é nome da base de regras e
            # o segundo é a lista de variáveis da base de regras.
            # Essas variáveis fazem parte dos possíveis objetivos.
            brCinema = RuleBaseCinema("Como ir ao Cinema",
                                      "[deslocamento, meioDeTransporte] :")
            self.app.add_rule_base(brCinema)
            self.app.menu()
        except Exception as e:
            print("Exception: RuleApp ", e.with_traceback())


if __name__ == '__main__':
    Main().main()
```

<p align='justify'> A classe <b>RuleBaseCinema</b> implementa a maior parte das regras e está no arquivo “RuleBaseCinema.py”, conforme se vê a seguir: </p>

``` python  
from ExpertSystem.api.esBooleanRuleBase import BooleanRuleBase
from ExpertSystem.api.esRuleVariable import RuleVariable
from ExpertSystem.api.esCondition import Condition
from ExpertSystem.api.esRule import Rule
from ExpertSystem.api.esClause import Clause    

class RuleBaseCinema:
    def __init__(self, nome, goals_list):
        self.br = BooleanRuleBase(nome)
        self.goals_list = goals_list

    def get_goal_list(self):
        return self.goals_list

    def create(self):
        distancia = RuleVariable(self.br, "distancia")
        distancia.set_labels("1 50")
        distancia.set_prompt_text("Qual é a distância até o cinema [1,50]?")

        deslocamento = RuleVariable(self.br, "deslocamento")
        deslocamento.set_labels("carro a-pe")
        deslocamento.set_prompt_text(
            "Qual é a forma de deslocameto [carro, a-pe]?")

        tempo = RuleVariable(self.br, "tempo")
        tempo.set_labels("0 60")
        tempo.set_prompt_text("Qual é o tempo disponível [1,60]?")

        local_do_cinema = RuleVariable(self.br, "localDoCinema")
        local_do_cinema.set_labels("centro bairro")
        local_do_cinema.set_prompt_text("Onde é o cinema [centro, bairro]]?")

        meio_de_transporte = RuleVariable(self.br, "meioDeTransporte")
        meio_de_transporte.set_labels(
            "taxi carro-proprio a-pe-triste a-pe-feliz")
        meio_de_transporte.set_prompt_text(
            "Qual é o meio de transporte [taxi, carro-proprio, a-pe-triste, a-pe-feliz]]?")

        clima = RuleVariable(self.br, "clima")
        clima.set_labels("ruim bom")
        clima.set_prompt_text("Como está o clima [bom, ruim]?")

        c_equals = Condition("=")
        c_more_then = Condition(">")
        c_less_than = Condition("<")

        Regra01 = Rule(self.br, "Regra 01",
                       [Clause(distancia, c_more_then, "5")],
                       Clause(deslocamento, c_equals, "carro"))

        Regra02 = Rule(self.br, "Regra 02",
                       [Clause(distancia, c_more_then, "1"),
                        Clause(tempo, c_less_than, "15")],
                       Clause(deslocamento, c_equals, "carro"))

        Regra03 = Rule(self.br, "Regra 03",
                       [Clause(distancia, c_more_then, "1"),
                        Clause(tempo, c_more_then, "15")],
                       Clause(deslocamento, c_equals, "a-pe"))

        Regra04 = Rule(self.br, "Regra 04",
                       [Clause(deslocamento, c_equals, "carro"),
                        Clause(local_do_cinema, c_equals, "centro")],
                       Clause(meio_de_transporte, c_equals, "taxi"))

        Regra05 = Rule(self.br, "Regra 05",
                       [Clause(deslocamento, c_equals, "carro"),
                        Clause(local_do_cinema, c_equals, "bairro")],
                       Clause(meio_de_transporte, c_equals, "carro-proprio"))

        Regra06 = Rule(self.br, "Regra 06",
                       [Clause(deslocamento, c_equals, "a-pe"),
                        Clause(clima, c_equals, "ruim")],
                       Clause(meio_de_transporte, c_equals, "a-pe-triste"))

        Regra07 = Rule(self.br, "Regra 07",
                       [Clause(deslocamento, c_equals, "a-pe"),
                        Clause(local_do_cinema, c_equals, "bom")],
                       Clause(meio_de_transporte, c_equals, "a-pe-feliz"))
        return self.br

    def demo_fc(self, LOG):
        LOG.append(
            " --- Ajustando valores para Transporte/Cinema para demo ForwardChain ---")
        self.br.set_variable_value("distancia", "2")
        self.br.set_variable_value("deslocamento", None)
        self.br.set_variable_value("tempo", "10")
        self.br.set_variable_value("localDoCinema", "centro")
        self.br.set_variable_value("meioDeTransporte", None)
        self.br.set_variable_value("clima", "ruim")
        self.br.display_variables(LOG)

    def demo_bc(self, LOG):
        LOG.append(
            " --- Ajustando valores para Transporte/Cinema para demo BackwardChain ---")
        self.br.set_variable_value("distancia", None)
        self.br.set_variable_value("deslocamento", None)
        self.br.set_variable_value("tempo", None)
        self.br.set_variable_value("localDoCinema", "centro")
        self.br.set_variable_value("meioDeTransporte", None)
        self.br.set_variable_value("clima", "ruim")
        self.br.display_variables(LOG)
```

<p align='justify'> Os dois últimos blocos de código, referentes às linhas linhas que seguem <b>def demo_fc(self, LOG):</b> e <b>def demo_bc(self, LOG):</b>, apresentam os valores de premissa iniciais. Esses valores podem ser modificados, o que possibilita verificar o comportamento final do software com os estados iniciais modificados.</p>  
<p align='justify'>  O código fonte que implementa o menu de opções, apresentado abaixo, demonstra funcionalidades recodificadas em Python e como podem ser chamadas.</p>  

``` python
class APP:
    def __init__(self, app):
        try:
            self.br = None
            self.ref_BR = None
            self.LOG = []
            self.LOG.append(app)
        except Exception as e:
            print("Exception lançada")
            print(e)

    def add_rule_base(self, ref_br):
        self.ref_BR = ref_br

    def show_log(self):
        for x in self.LOG:
            print(x, end=' ')

    def show_log_new_line(self):
        for x in self.LOG:
            print(x, end='\n')

    def clear_text(self):
        self.LOG.clear()
        self.LOG.append("")
        self.br.reset()

    def menu(self):
        naoCarregada = False
        while True:
            print('\n              : [0] sair', end='\n')
            print('        REGRAS: [1] carregar, [2] mostrar', end='\n')
            print(' FORWARD-CHAIN: [3] carregar variaveis, [4] executar, [7] reset', end='\n')
            print('BACKWARD-CHAIN: [5] carregar variaveis, [6] executar, [7] reset', end='\n')
            print('Digite sua opcao: ')
            option = int(input())

            if option == 0:
                return
            elif option == 1:
                if not naoCarregada:
                    self.br = self.ref_BR.create()
                    naoCarregada = True
                else:
                    print("Base de regas já foi carregada!!")
            elif option == 2:
                self.br.display_rules(self.LOG)
                self.show_log()
                self.LOG = []
            elif option == 3:
                self.ref_BR.demo_fc(self.LOG)
                self.show_log_new_line()
                self.LOG = []
            elif option == 4:
                self.LOG.append(" --- Starting Inferencing Cycle --- ")
                self.br.forward_chain()
                self.br.display_variables(self.LOG)
                self.show_log_new_line()
                self.LOG = []
            elif option == 5:
                self.ref_BR.demo_bc(self.LOG)
                self.show_log_new_line()
                self.LOG = []
            elif option == 6:
                goal_list = self.ref_BR.get_goal_list()
                print("Informe a variavel objetivo ", goal_list)
                goal = input()
                goal_var = self.br.get_variable(goal)
                if goal_var is not None:
                    self.br.backward_chain(goal)
                else:
                    self.LOG.append("goalVar.__name__: NAO ENCONTEADA")
                self.LOG.append(" --- Ending Inferencing Cycle --- ")
                if goal_var is not None:
                    result = goal_var.get_value()
                else:
                    result = "DESCONHECIDO"
                self.LOG.append("RESULTADO: " + str(result))
                self.br.display_variables(self.LOG)
                self.show_log_new_line()
                self.LOG = []
            elif option == 7:
                self.clear_text()

```

> ### <b>LINKS ÚTEIS:</b>  
>
>https://www.w3schools.com/python/  
>
>https://www.python.org/about/gettingstarted/  
>
>https://www.codecademy.com/learn/learn-python  
>
> </br>
>
> ### <b>REFERÊNCIAS BIBLIOGRÁFICAS</b>   
>
>BIGUS, Joseph P.; BIGUS, Jennifer. <b>Constructing intelligent agents using Java.</b> 2001. John Wiley & Sons; 2nd edição.
>
>SCALABRIN, Edson E. <b>Material de apoio para a disciplina “Engenharia de Conhecimento”</b>. 2019. PUCPR
"""